{"version":3,"names":[],"mappings":"","sources":["dist.js"],"sourcesContent":["\"use strict\";\nlet environment = require(\"./environment\");\nlet path = require(\"path\");\nlet urljoin = require(\"url-join\");\nlet Bluebird = require(\"bluebird\");\nlet fs = Bluebird.promisifyAll(require(\"fs-extra\"));\nlet _ = require(\"lodash\");\nlet CMLog = require(\"./cmLog\");\nlet TargetOptions = require(\"./targetOptions\");\nlet runtimePaths = require(\"./runtimePaths\");\nlet async = Bluebird.coroutine;\nlet Downloader = require(\"./downloader\");\n\nfunction testSum(sums, sum, fPath) {\n    let serverSum = _.first(sums.filter(function (s) {\n        return s.getPath === fPath;\n    }));\n    if (serverSum && serverSum.sum === sum) {\n        return;\n    }\n    throw new Error(\"SHA sum of file '\" + fPath + \"' mismatch!\");\n}\n\nfunction Dist(options) {\n    this.options = options || {};\n    this.log = new CMLog(this.options);\n    this.targetOptions = new TargetOptions(this.options);\n    this.downloader = new Downloader(this.options);\n}\n\n// Props\nObject.defineProperties(Dist.prototype, {\n    internalPath: {\n        get: function () {\n            return path.join(\n                environment.home,\n                \".cmake-js\",\n                (this.targetOptions.runtime) + \"-\" + this.targetOptions.arch,\n                \"v\" + this.targetOptions.runtimeVersion);\n        }\n    },\n    externalPath: {\n        get: function () {\n            return runtimePaths.get(this.targetOptions).externalPath;\n        }\n    },\n    downloaded: {\n        get: function () {\n            let result = false;\n            try {\n                let stat = fs.lstatSync(this.internalPath);\n                if (stat.isDirectory()) {\n                    if (this.headerOnly) {\n                        stat = fs.lstatSync(path.join(this.internalPath, \"include/node/node.h\"));\n                        result = !stat.isDirectory();\n                    }\n                    else {\n                        stat = fs.lstatSync(path.join(this.internalPath, \"src/node.h\"));\n                        if (!stat.isDirectory()) {\n                            stat = fs.lstatSync(path.join(this.internalPath, \"deps/v8/include/v8.h\"));\n                            result = !stat.isDirectory();\n                        }\n                    }\n                }\n            }\n            catch (e) {\n                _.noop(e);\n            }\n            return result;\n        }\n    },\n    winLibDir: {\n        get: function () {\n            return path.join(this.internalPath, runtimePaths.get(this.targetOptions).winLibDir);\n        }\n    },\n    winLibPath: {\n        get: function () {\n            return path.join(this.winLibDir, runtimePaths.get(this.targetOptions).winLibName);\n        }\n    },\n    headerOnly: {\n        get: function () {\n            return runtimePaths.get(this.targetOptions).headerOnly;\n        }\n    }\n});\n\n// Methods\nDist.prototype.ensureDownloaded = async(function* () {\n    if (!this.downloaded) {\n        yield this.download();\n    }\n});\n\nDist.prototype.download = async(function* () {\n    let log = this.log;\n    log.info(\"DIST\", \"Downloading distribution files.\");\n    yield fs.mkdirpAsync(this.internalPath);\n    let sums = yield this._downloadShaSums();\n    yield Bluebird.all([this._downloadLib(sums), this._downloadTar(sums)]);\n});\n\nDist.prototype._downloadShaSums = async(function* () {\n    if (this.targetOptions.runtime === \"node\" || this.targetOptions.runtime === \"iojs\") {\n        let sumUrl = urljoin(this.externalPath, \"SHASUMS256.txt\");\n        let log = this.log;\n        log.http(\"DIST\", \"\\t- \" + sumUrl);\n        return (yield this.downloader.downloadString(sumUrl))\n            .split(\"\\n\")\n            .map(function (line) {\n                let parts = line.split(/\\s+/);\n                return {\n                    getPath: parts[1],\n                    sum: parts[0]\n                };\n            })\n            .filter(function (i) {\n                return i.getPath && i.sum;\n            });\n    }\n    else {\n        return null;\n    }\n});\n\nDist.prototype._downloadTar = async(function* (sums) {\n    let log = this.log;\n    let self = this;\n    let tarLocalPath = runtimePaths.get(self.targetOptions).tarPath;\n    let tarUrl = urljoin(self.externalPath, tarLocalPath);\n    log.http(\"DIST\", \"\\t- \" + tarUrl);\n\n    let sum = yield this.downloader.downloadTgz(tarUrl, {\n        hash: sums ? \"sha256\" : null,\n        path: self.internalPath,\n        strip: 1,\n        filter: function () {\n            if (this.path === self.internalPath) {\n                return true;\n            }\n            let ext = path.extname(this.path);\n            return ext && ext.toLowerCase() === \".h\";\n        }\n    });\n\n    if (sums) {\n        testSum(sums, sum, tarLocalPath);\n    }\n});\n\nDist.prototype._downloadLib = async(function* (sums) {\n    let log = this.log;\n    let self = this;\n    if (!environment.isWin) {\n        return;\n    }\n\n    let paths = runtimePaths.get(self.targetOptions);\n    let subDir = paths.winLibDir;\n    let fn = paths.winLibName;\n    let fPath = subDir ? urljoin(subDir, fn) : fn;\n    let libUrl = urljoin(self.externalPath, fPath);\n    log.http(\"DIST\", \"\\t- \" + libUrl);\n\n    yield fs.mkdirpAsync(path.join(self.internalPath, subDir));\n\n    let sum = yield this.downloader.downloadFile(libUrl, {\n        path: path.join(self.internalPath, fPath),\n        hash: sums ? \"sha256\" : null\n    });\n\n    if (sums) {\n        testSum(sums, sum, fPath);\n    }\n});\n\nmodule.exports = Dist;\n"],"file":"dist.js","sourceRoot":"/source/"}